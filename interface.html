<!doctype html>
<html class="no-js" lang="">

<head>
  <meta charset="utf-8">
  <title>Get Richie or Die Tryin'</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
@import url('https://fonts.googleapis.com/css?family=Literata:400,500,600,700&display=swap');

body {
	font-family: 'Literata', serif;	
	text-align: center;
	font-size: 16px;
}

.banner {
	font-size: 40px;
	padding: 15px 0;
	border-bottom: 1px solid #CCC;
	margin-bottom: 15px;
}

.key {
	stroke: black;
}

.white {
	fill: white;
}

.black {
	fill: black;
}

#piano_88_keys {
	margin-top: 20px;		
}

#controls {
	max-width: 1200px;
	margin: 5px auto;
	position: relative;
}

button {
	font-size: 20px;
	cursor: pointer;
	outline: none;
	background-color: white;
	border: 1px solid black;
	width: 100px;
	padding: 5px 10px 4px 10px;
	line-height: 22px;
	border-radius: 3px;
	vertical-align: top;
}

button.selected {
	background-color: #FFFFEE;
}

#control_panel > a {
	display: none;
}

#admin {
	text-align: left;
}

.label {
	font-size: 12px;
	fill: black;
	text-anchor: middle;
	font-family: "Arial";
}

#notespace {
	background-color: #EEE;
}

.domain {
	display: none;
}

.tick line {
	stroke: white;
	stroke-width: 2px;
}

  </style>



</head>

<body>
	<div class="banner">The Piano, Seen</div>
	<div id="controls">
		<div id="admin">
			<button id="start">Start</button>
			<button id="stop">Stop</button>
			<button id="load">Load</button>
			<button id="save">Save</button>
		</div>
		<div id="options">
			<button id="use_flats" class="selected">Flats</button>
			<button id="use_sharps">Sharps</button>
		</div>
		<a id="save_anchor"></a>
	</div>
	<div id="piano_88_keys"></div>
	<div id="notespace"></div>

	<!--<script type="text/javascript" src="src/webmidi.js"></script>-->
	<script type="text/javascript" src="src/d3.v5.min.js"></script>
	<script type="text/javascript">
const NOTES = [
	{ "names": "A Gx Bbb", "color": "white" },
	{ "names": "As Bb", "color": "black" },
	{ "names": "B Ax Cb", "color": "white" },
	{ "names": "C Bs Dbb", "color": "white" },
	{ "names": "Cs Db", "color": "black" },
	{ "names": "D Cx Ebb", "color": "white" },
	{ "names": "Ds Eb", "color": "black" },
	{ "names": "E Dx Fb", "color": "white" },
	{ "names": "F Es Gbb", "color": "white" },
	{ "names": "Fs Gb", "color": "black" },
	{ "names": "G Fx Abb", "color": "white" },
	{ "names": "Gs Ab", "color": "black" }
];

const BLACK_KEY_OFFSETS = {
	"As": 19.5,
	"Cs": 14.333333,
	"Ds": 18.666666,
	"Fs": 13.25,
	"Gs": 20.25
};

const KEYS = [];
let posW = -23;
let posB = 0;

// build keyboard
for (let c = 0; c < 88; c += 1) {
	let note = Object.assign({}, NOTES[c % 12]);
	note.index = c + 21;	
	note.names = note.names.split(/ /g);
	note.register = Math.floor((c - 3) / 12) + 1;
	note.id = note.names[0] + note.register;
	if (note.color === "white") {
		posW += 23;
		note.x = posW;
	} else {
		note.x = posW + BLACK_KEY_OFFSETS[note.names[0]];
	}
	KEYS.push(note);
}

var white_keys = keys.filter(function(d) {
	return d.color === "white";
});

var black_keys = keys.filter(function(d) {
	return d.color === "black";
});

var svgPiano = d3.select("#piano_88_keys").append("svg")
    .attr("width", 1200)
    .attr("height", 140);

var g_white_keys = svgPiano.append("g").attr("id", "white_keys");
var g_black_keys = svgPiano.append("g").attr("id", "black_keys");
var g_labels = svgPiano.append("g").attr("id", "labels");

g_white_keys.selectAll(".key")
	.data(white_keys)
	.enter()
	.append("rect")
	.attr("class", function(d) {
		return "key white " + d.names.join(" ");
	})
	.attr("width", 23)
	.attr("height", 120)
	.attr("x", function(d) { return d.x; })
	.attr("y", 0)
	.attr("id", function(d) { return "note_" + d.index; });

g_black_keys.selectAll(".key")
	.data(black_keys)
	.enter()
	.append("rect")
	.attr("class", function(d) {
		return "key black " + d.names.join(" ");
	})
	.attr("width", 13)
	.attr("height", 80)
	.attr("x", function(d) { return d.x; })
	.attr("y", 0)
	.attr("id", function(d) { return "note_" + d.index; })

var C4 = white_keys.filter(d => {
	return d.id == "C4";
})[0];

g_labels.append("text")
	.attr("class", "label")
	.text("C4")
	.attr("x", C4.x + 23 / 2)
	.attr("y", 120 - 6);


var MODE = "flats";
var data = [];

window.data = data;

d3.selectAll("button").on("click", function() {
	if (this.id === "start") {
		allowMIDIs();
		return;
	}

	if (this.id === "stop") {
		endRecording();
		return;
	}

	if (this.id === "save") {
		downloadFile(data);
		return;
	}

	if (this.id === "load") {
		d3.json("./samples/chopin.json").then(function(json) {
			simulation(json);
		});
		return;
	}

	// flats vs sharps
	if (d3.select(this).classed("selected")) {
		return;
	}

	d3.selectAll("button").classed("selected", false);
	d3.select(this).classed("selected", true);
	if (this.id === "use_flats") {
		MODE = "flats";
	} else {
		MODE = "sharps";
	}
});

function downloadFile(json) {
	var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(json));
	var anchor = document.getElementById('save_anchor');
	anchor.setAttribute("href", dataStr );
	anchor.setAttribute("download", "score.json");
	anchor.click();	
}
	</script>



	<script type="text/javascript">


function allowMIDIs() {
	console.log("Requesting MIDI Acess");
	navigator.requestMIDIAccess({ sysex: true })
		.then(onMIDISuccess, onMIDIFailure);
}

function onMIDISuccess(midiAccess) {
	console.log("Successfully loaded MIDIs!");
	window.midiAccess = midiAccess;

	var inputs = midiAccess.inputs;
	var outputs = midiAccess.outputs;

	// console.log(inputs, outputs);

	if (inputs.size === 0) {
		// console.log("No inputs");
		return;
	}

	for (var input of midiAccess.inputs.values()) {
		console.log(input)
		input.onmidimessage = getMIDIMessage;
	}

	startRecording();
}	

function onMIDIFailure(midiAccess) {
	console.log(midiAccess);
}	

function getMIDIMessage(message) {
	var command = message.data[0];
	var note = message.data[1];
	var velocity = (message.data.length > 2) ? message.data[2] : 0; // a velocity value might not be included with a noteOff command
	var timestamp = message.timeStamp;
	if (command === 144) {
		console.log(message);
	}

	switch (command) {
		case 144: // noteOn
			if (velocity > 0) {
				noteOn(note, timestamp, velocity);
			} else {
				noteOff(note, timestamp);
			}
			break;
		case 128: // noteOff
			noteOff(note, timestamp);
			break;
		// we could easily expand this switch statement to cover other types of commands such as controllers or sysex
	}
}

function noteOn(value, timestamp, velocity) {
	var note = Object.assign({}, keys[value - 21]);
	note.status = "on";
	note.start = timestamp;
	note.velocity = velocity;
	data.push(note);

	console.log(note.id, "on");

}

function noteOff(value, timestamp, velocity) {
	var note = Object.assign({}, keys[value - 21]);
	note.status = "off";
	note.timestamp = timestamp;
	data.push(note);

	console.log(note.id, "off");
}
	</script>

	<script type="text/javascript">
var svgNotes = d3.select("#notespace").append("svg")
    .attr("width", 1200)
    .attr("height", 600);

console.log(keys);

var xScale = d3.scaleLinear()
	.domain([0, 1200]) // we'll use `note.x` instead of the value since black key positions are staggered
    .range([0, 1200]);

var yScale = d3.scaleLinear()
	.domain([0, 600]) // likewise, we're going to get a little tricky with y position to avoid long empty spaces
    .range([0, 600]);

var rules = keys.map(function(d) { 
	return d.x + (d.color === "white" ? 23 / 2 : 13 / 2);
	// return d.index;
});

var xAxis = d3.axisTop(xScale)
	.tickValues(rules)
	.tickSize(-600)
	.tickFormat("");


svgNotes.append("g")
	.attr("id", "x_axis")
    .attr("transform", "translate(0,30)")
    .call(xAxis);


function visualizeNote(isFinished) {

}
	</script>
	<script type="text/javascript">
var TIME = 0;
var TIME_STEP = 50;
var CLOCK;

function startRecording() {
	CLOCK = setInterval(function() {
		TIME += TIME_STEP;
	}, TIME_STEP);
}

function endRecording() {
	clearTimeout(CLOCK);
}

let notes = [];
let pending = {};

function simulation(notes) {
	var offset = notes[0].timestamp;
	console.log(offset);

	// brief pause before we begin
	setTimeout(function() {
		notes.forEach(function(note) {
			if (note.status === "on") {
				if (pending[note.id]) {
					console.log("Collision: Still have a pending note for", note.id);
					return;
				}
			}

			pending[note.id] = note;
			note.start = note.timestamp;
		});		
	}, 500);

}




	</script>

</body>

</html>